// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from "@tanstack/react-query";

import { client } from "../client.gen";
import {
  apiKeysCreateApiKey,
  apiKeysListApiKeys,
  apiKeysRevokeApiKey,
  authDemoLogin,
  authGetUser,
  authLoginUser,
  authLogout,
  authOidcCallback,
  authVerifyAuth,
  entriesDeleteEntry,
  entriesDownload,
  entriesGetEntryById,
  entriesGetEntryModel,
  entriesGetEntryShareLink,
  entriesListUserEntries,
  entriesUpdateEntry,
  entriesUpdateEntryModel,
  entriesUploadCvsx,
  healthCheckHealthCheck,
  type Options,
  shareLinksDownload,
  shareLinksGetEntryByShareLink,
  shareLinksGetEntryModel,
  shareLinksUpdateShareLink,
} from "../sdk.gen";
import type {
  ApiKeysCreateApiKeyData,
  ApiKeysCreateApiKeyError,
  ApiKeysCreateApiKeyResponse,
  ApiKeysListApiKeysData,
  ApiKeysListApiKeysResponse,
  ApiKeysRevokeApiKeyData,
  ApiKeysRevokeApiKeyError,
  ApiKeysRevokeApiKeyResponse,
  AuthDemoLoginData,
  AuthDemoLoginError,
  AuthGetUserData,
  AuthGetUserResponse,
  AuthLoginUserData,
  AuthLoginUserError,
  AuthLogoutData,
  AuthOidcCallbackData,
  AuthOidcCallbackError,
  AuthVerifyAuthData,
  AuthVerifyAuthResponse,
  EntriesDeleteEntryData,
  EntriesDeleteEntryError,
  EntriesDownloadData,
  EntriesDownloadError,
  EntriesGetEntryByIdData,
  EntriesGetEntryByIdError,
  EntriesGetEntryByIdResponse,
  EntriesGetEntryModelData,
  EntriesGetEntryModelError,
  EntriesGetEntryModelResponse,
  EntriesGetEntryShareLinkData,
  EntriesGetEntryShareLinkError,
  EntriesGetEntryShareLinkResponse,
  EntriesListUserEntriesData,
  EntriesListUserEntriesError,
  EntriesListUserEntriesResponse,
  EntriesUpdateEntryData,
  EntriesUpdateEntryError,
  EntriesUpdateEntryModelData,
  EntriesUpdateEntryModelError,
  EntriesUpdateEntryModelResponse,
  EntriesUpdateEntryResponse,
  EntriesUploadCvsxData,
  EntriesUploadCvsxError,
  EntriesUploadCvsxResponse,
  HealthCheckHealthCheckData,
  HealthCheckHealthCheckError,
  HealthCheckHealthCheckResponse,
  ShareLinksDownloadData,
  ShareLinksDownloadError,
  ShareLinksGetEntryByShareLinkData,
  ShareLinksGetEntryByShareLinkError,
  ShareLinksGetEntryByShareLinkResponse,
  ShareLinksGetEntryModelData,
  ShareLinksGetEntryModelError,
  ShareLinksGetEntryModelResponse,
  ShareLinksUpdateShareLinkData,
  ShareLinksUpdateShareLinkError,
  ShareLinksUpdateShareLinkResponse,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl:
      options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const healthCheckHealthCheckQueryKey = (
  options?: Options<HealthCheckHealthCheckData>,
) => createQueryKey("healthCheckHealthCheck", options);

/**
 * Health Check
 */
export const healthCheckHealthCheckOptions = (
  options?: Options<HealthCheckHealthCheckData>,
) =>
  queryOptions<
    HealthCheckHealthCheckResponse,
    HealthCheckHealthCheckError,
    HealthCheckHealthCheckResponse,
    ReturnType<typeof healthCheckHealthCheckQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthCheckHealthCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthCheckHealthCheckQueryKey(options),
  });

export const apiKeysListApiKeysQueryKey = (
  options?: Options<ApiKeysListApiKeysData>,
) => createQueryKey("apiKeysListApiKeys", options);

/**
 * List Api Keys
 */
export const apiKeysListApiKeysOptions = (
  options?: Options<ApiKeysListApiKeysData>,
) =>
  queryOptions<
    ApiKeysListApiKeysResponse,
    DefaultError,
    ApiKeysListApiKeysResponse,
    ReturnType<typeof apiKeysListApiKeysQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiKeysListApiKeys({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiKeysListApiKeysQueryKey(options),
  });

/**
 * Create Api Key
 */
export const apiKeysCreateApiKeyMutation = (
  options?: Partial<Options<ApiKeysCreateApiKeyData>>,
): UseMutationOptions<
  ApiKeysCreateApiKeyResponse,
  ApiKeysCreateApiKeyError,
  Options<ApiKeysCreateApiKeyData>
> => {
  const mutationOptions: UseMutationOptions<
    ApiKeysCreateApiKeyResponse,
    ApiKeysCreateApiKeyError,
    Options<ApiKeysCreateApiKeyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await apiKeysCreateApiKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revoke Api Key
 */
export const apiKeysRevokeApiKeyMutation = (
  options?: Partial<Options<ApiKeysRevokeApiKeyData>>,
): UseMutationOptions<
  ApiKeysRevokeApiKeyResponse,
  ApiKeysRevokeApiKeyError,
  Options<ApiKeysRevokeApiKeyData>
> => {
  const mutationOptions: UseMutationOptions<
    ApiKeysRevokeApiKeyResponse,
    ApiKeysRevokeApiKeyError,
    Options<ApiKeysRevokeApiKeyData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await apiKeysRevokeApiKey({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authLoginUserQueryKey = (options?: Options<AuthLoginUserData>) =>
  createQueryKey("authLoginUser", options);

/**
 * Login User
 */
export const authLoginUserOptions = (options?: Options<AuthLoginUserData>) =>
  queryOptions<
    unknown,
    AuthLoginUserError,
    unknown,
    ReturnType<typeof authLoginUserQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authLoginUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authLoginUserQueryKey(options),
  });

export const authOidcCallbackQueryKey = (
  options: Options<AuthOidcCallbackData>,
) => createQueryKey("authOidcCallback", options);

/**
 * Oidc Callback
 */
export const authOidcCallbackOptions = (
  options: Options<AuthOidcCallbackData>,
) =>
  queryOptions<
    unknown,
    AuthOidcCallbackError,
    unknown,
    ReturnType<typeof authOidcCallbackQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authOidcCallback({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authOidcCallbackQueryKey(options),
  });

/**
 * Logout
 */
export const authLogoutMutation = (
  options?: Partial<Options<AuthLogoutData>>,
): UseMutationOptions<unknown, DefaultError, Options<AuthLogoutData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AuthLogoutData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authLogout({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authGetUserQueryKey = (options?: Options<AuthGetUserData>) =>
  createQueryKey("authGetUser", options);

/**
 * Get User
 */
export const authGetUserOptions = (options?: Options<AuthGetUserData>) =>
  queryOptions<
    AuthGetUserResponse,
    DefaultError,
    AuthGetUserResponse,
    ReturnType<typeof authGetUserQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authGetUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authGetUserQueryKey(options),
  });

export const authVerifyAuthQueryKey = (options?: Options<AuthVerifyAuthData>) =>
  createQueryKey("authVerifyAuth", options);

/**
 * Verify Auth
 */
export const authVerifyAuthOptions = (options?: Options<AuthVerifyAuthData>) =>
  queryOptions<
    AuthVerifyAuthResponse,
    DefaultError,
    AuthVerifyAuthResponse,
    ReturnType<typeof authVerifyAuthQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authVerifyAuth({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authVerifyAuthQueryKey(options),
  });

export const authDemoLoginQueryKey = (options?: Options<AuthDemoLoginData>) =>
  createQueryKey("authDemoLogin", options);

/**
 * Demo Login
 */
export const authDemoLoginOptions = (options?: Options<AuthDemoLoginData>) =>
  queryOptions<
    unknown,
    AuthDemoLoginError,
    unknown,
    ReturnType<typeof authDemoLoginQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authDemoLogin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authDemoLoginQueryKey(options),
  });

export const entriesListUserEntriesQueryKey = (
  options?: Options<EntriesListUserEntriesData>,
) => createQueryKey("entriesListUserEntries", options);

/**
 * List User Entries
 */
export const entriesListUserEntriesOptions = (
  options?: Options<EntriesListUserEntriesData>,
) =>
  queryOptions<
    EntriesListUserEntriesResponse,
    EntriesListUserEntriesError,
    EntriesListUserEntriesResponse,
    ReturnType<typeof entriesListUserEntriesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entriesListUserEntries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entriesListUserEntriesQueryKey(options),
  });

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = { ...queryKey[0] };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const entriesListUserEntriesInfiniteQueryKey = (
  options?: Options<EntriesListUserEntriesData>,
): QueryKey<Options<EntriesListUserEntriesData>> =>
  createQueryKey("entriesListUserEntries", options, true);

/**
 * List User Entries
 */
export const entriesListUserEntriesInfiniteOptions = (
  options?: Options<EntriesListUserEntriesData>,
) =>
  infiniteQueryOptions<
    EntriesListUserEntriesResponse,
    EntriesListUserEntriesError,
    InfiniteData<EntriesListUserEntriesResponse>,
    QueryKey<Options<EntriesListUserEntriesData>>,
    | number
    | Pick<
        QueryKey<Options<EntriesListUserEntriesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<EntriesListUserEntriesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await entriesListUserEntries({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: entriesListUserEntriesInfiniteQueryKey(options),
    },
  );

/**
 * Upload Cvsx
 */
export const entriesUploadCvsxMutation = (
  options?: Partial<Options<EntriesUploadCvsxData>>,
): UseMutationOptions<
  EntriesUploadCvsxResponse,
  EntriesUploadCvsxError,
  Options<EntriesUploadCvsxData>
> => {
  const mutationOptions: UseMutationOptions<
    EntriesUploadCvsxResponse,
    EntriesUploadCvsxError,
    Options<EntriesUploadCvsxData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entriesUploadCvsx({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete Entry
 */
export const entriesDeleteEntryMutation = (
  options?: Partial<Options<EntriesDeleteEntryData>>,
): UseMutationOptions<
  unknown,
  EntriesDeleteEntryError,
  Options<EntriesDeleteEntryData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    EntriesDeleteEntryError,
    Options<EntriesDeleteEntryData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entriesDeleteEntry({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entriesGetEntryByIdQueryKey = (
  options: Options<EntriesGetEntryByIdData>,
) => createQueryKey("entriesGetEntryById", options);

/**
 * Get Entry By Id
 */
export const entriesGetEntryByIdOptions = (
  options: Options<EntriesGetEntryByIdData>,
) =>
  queryOptions<
    EntriesGetEntryByIdResponse,
    EntriesGetEntryByIdError,
    EntriesGetEntryByIdResponse,
    ReturnType<typeof entriesGetEntryByIdQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entriesGetEntryById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entriesGetEntryByIdQueryKey(options),
  });

/**
 * Update Entry
 */
export const entriesUpdateEntryMutation = (
  options?: Partial<Options<EntriesUpdateEntryData>>,
): UseMutationOptions<
  EntriesUpdateEntryResponse,
  EntriesUpdateEntryError,
  Options<EntriesUpdateEntryData>
> => {
  const mutationOptions: UseMutationOptions<
    EntriesUpdateEntryResponse,
    EntriesUpdateEntryError,
    Options<EntriesUpdateEntryData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entriesUpdateEntry({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entriesGetEntryShareLinkQueryKey = (
  options: Options<EntriesGetEntryShareLinkData>,
) => createQueryKey("entriesGetEntryShareLink", options);

/**
 * Get Entry Share Link
 */
export const entriesGetEntryShareLinkOptions = (
  options: Options<EntriesGetEntryShareLinkData>,
) =>
  queryOptions<
    EntriesGetEntryShareLinkResponse,
    EntriesGetEntryShareLinkError,
    EntriesGetEntryShareLinkResponse,
    ReturnType<typeof entriesGetEntryShareLinkQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entriesGetEntryShareLink({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entriesGetEntryShareLinkQueryKey(options),
  });

export const entriesGetEntryModelQueryKey = (
  options: Options<EntriesGetEntryModelData>,
) => createQueryKey("entriesGetEntryModel", options);

/**
 * Get Entry Model
 */
export const entriesGetEntryModelOptions = (
  options: Options<EntriesGetEntryModelData>,
) =>
  queryOptions<
    EntriesGetEntryModelResponse,
    EntriesGetEntryModelError,
    EntriesGetEntryModelResponse,
    ReturnType<typeof entriesGetEntryModelQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entriesGetEntryModel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entriesGetEntryModelQueryKey(options),
  });

/**
 * Update Entry Model
 */
export const entriesUpdateEntryModelMutation = (
  options?: Partial<Options<EntriesUpdateEntryModelData>>,
): UseMutationOptions<
  EntriesUpdateEntryModelResponse,
  EntriesUpdateEntryModelError,
  Options<EntriesUpdateEntryModelData>
> => {
  const mutationOptions: UseMutationOptions<
    EntriesUpdateEntryModelResponse,
    EntriesUpdateEntryModelError,
    Options<EntriesUpdateEntryModelData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await entriesUpdateEntryModel({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const entriesDownloadQueryKey = (
  options: Options<EntriesDownloadData>,
) => createQueryKey("entriesDownload", options);

/**
 * Download
 */
export const entriesDownloadOptions = (options: Options<EntriesDownloadData>) =>
  queryOptions<
    unknown,
    EntriesDownloadError,
    unknown,
    ReturnType<typeof entriesDownloadQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await entriesDownload({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: entriesDownloadQueryKey(options),
  });

export const shareLinksGetEntryByShareLinkQueryKey = (
  options: Options<ShareLinksGetEntryByShareLinkData>,
) => createQueryKey("shareLinksGetEntryByShareLink", options);

/**
 * Get Entry By Share Link
 */
export const shareLinksGetEntryByShareLinkOptions = (
  options: Options<ShareLinksGetEntryByShareLinkData>,
) =>
  queryOptions<
    ShareLinksGetEntryByShareLinkResponse,
    ShareLinksGetEntryByShareLinkError,
    ShareLinksGetEntryByShareLinkResponse,
    ReturnType<typeof shareLinksGetEntryByShareLinkQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await shareLinksGetEntryByShareLink({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: shareLinksGetEntryByShareLinkQueryKey(options),
  });

export const shareLinksGetEntryModelQueryKey = (
  options: Options<ShareLinksGetEntryModelData>,
) => createQueryKey("shareLinksGetEntryModel", options);

/**
 * Get Entry Model
 */
export const shareLinksGetEntryModelOptions = (
  options: Options<ShareLinksGetEntryModelData>,
) =>
  queryOptions<
    ShareLinksGetEntryModelResponse,
    ShareLinksGetEntryModelError,
    ShareLinksGetEntryModelResponse,
    ReturnType<typeof shareLinksGetEntryModelQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await shareLinksGetEntryModel({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: shareLinksGetEntryModelQueryKey(options),
  });

export const shareLinksDownloadQueryKey = (
  options: Options<ShareLinksDownloadData>,
) => createQueryKey("shareLinksDownload", options);

/**
 * Download
 */
export const shareLinksDownloadOptions = (
  options: Options<ShareLinksDownloadData>,
) =>
  queryOptions<
    unknown,
    ShareLinksDownloadError,
    unknown,
    ReturnType<typeof shareLinksDownloadQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await shareLinksDownload({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: shareLinksDownloadQueryKey(options),
  });

/**
 * Update Share Link
 */
export const shareLinksUpdateShareLinkMutation = (
  options?: Partial<Options<ShareLinksUpdateShareLinkData>>,
): UseMutationOptions<
  ShareLinksUpdateShareLinkResponse,
  ShareLinksUpdateShareLinkError,
  Options<ShareLinksUpdateShareLinkData>
> => {
  const mutationOptions: UseMutationOptions<
    ShareLinksUpdateShareLinkResponse,
    ShareLinksUpdateShareLinkError,
    Options<ShareLinksUpdateShareLinkData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await shareLinksUpdateShareLink({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
